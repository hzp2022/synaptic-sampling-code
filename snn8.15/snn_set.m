function net = snn_set( net, varargin )
% snn_set: sets SNN network parameters.  设置SNN网络参数。
%
% net = snn_set( net, 'parameter', <value>, ... )
%
% Sets network parameters. The list of 'parameter'
% <value> pairs can have arbitrary length. the
% default parameters that can be set here are:
% 设置网络参数。参数<value>对的列表可以有任意的长度，这里可以设置的默认参数有：
%
% name                type    default  description
% ---------------------------------------------------------------------
% train_method        string  '*'      The method used for training       用于训练的方法
% sample_method       string  '*'      The method used for sampling       用于采样的方法
% performance_method  string  '*'      The performance evaluation method  性能评估方法
%
% A list of all wta methods can be generated by
% the function <a href = "matlab:snn_list_methods">snn_list_methods</a>.
% The train-, sample- and performance methods may add
% additional parameters to the network through their
% meta data. If the parameter list contains ...,'reset_fields', true, ...
% all fields will be newly allocated.
% 所有WTA方法的列表可以由函数<a href = "matlab:snn_list_methods">snn_list_methods</a>生成。
% 训练、采样和性能方法可以通过它们的元数据向网络添加附加参数。如果参数列表包含...,'Reset_field',true,...
% 所有字段都将重新分配。
%
% input
%   net:       A snn network.  一个SNN网络。
%              See <a href="matlab:help snn_new">snn_new</a>.
%
% output
%   net:       The modified network structure.  修改后的网络结构。         
%
% see also
%   <a href="matlab:help snn_parse_meta_data">snn_parse_meta_data</a>
%   <a href = "matlab:snn_list_methods">snn_list_methods</a>
%   <a href = "matlab:snn_new">snn_new</a>
%
% David Kappel 30.06.2010
%

    if (nargin<1)
        error('Not enought input arguments!');
    end

    if ~isstruct( net )
        error('Unexpected argument type for ''net''!');
    end

    
    required_methods = net.p_required_methods;  % 定义cell数组required_methods并初始化为net的p_required_methods   
    external_packages = {};
    method_fcn_names = {};
    
    cur_method_idx = 1;
    
    % 遍历train、sample、performance三个方法文件，从文件中提取一些要用到的meta_data并添加至net中
    while (cur_method_idx <= length(required_methods))  
        
        % 获取当前方法的信息
        cur_method_prefix = required_methods{cur_method_idx};  
        cur_method_idx = cur_method_idx + 1;        
        cur_method_name = strcat(cur_method_prefix,'_method');        
        default_method = '*';  % 定义默认方法并初始化为'*'
        
        if isfield(net,cur_method_name)  % 如果cur_method_name是net的字段，则将net的cur_method_name字段值设为默认方法
            default_method = net.(cur_method_name);
        end
        
        [ net.(cur_method_name), reset_fields, varargin ] = ...  % 处理传递给函数的参数
            snn_process_options( varargin, cur_method_name, default_method, 'reset_fields', false );

        [fcn_name,net.(cur_method_name)] = snn_find_method( cur_method_prefix, net.(cur_method_name) );  % 获取方法全名和方法名称后缀
        net.(strcat('p_',cur_method_prefix,'_fcn')) = eval( ['@(net,data,ct)(',fcn_name,'(net,data,ct))'] );  % eval计算MATLAB表达式，这里仅是字符串拼接得到了一个函数句柄    
        cur_params = snn_dispatch_meta_data( [fcn_name,'.m'], 'parameters', 1 );  % 从fcn_name.m中读取parameters部分的元数据（每次读一个字段）
        pack_using = snn_parse_meta_data( [fcn_name,'.m'], 'using', 0 );  % 从fcn_name.m中读取using（要使用哪些包）部分的元数据，首次运行时，目标文件无'%@using:'的行，故为空。（num_fileds参数为0：每次读一个值）
        external_packages = { external_packages{:}, pack_using{:} };  
        method_fcn_names = { method_fcn_names{:}, fcn_name };
        
        % 遍历cur_params，将cur_params中指定参数添加到net结构体中，同时更新required_methods这个元胞数组。
        for i=1:2:length(cur_params)
            if strcmp(cur_params{i},'p_required_methods')  
                for new_method = snn_parse_args(cur_params{i+1})  % 将p_required_methods字段的字段值解析成字符串元胞数组后赋值给new_method
                    if isempty(strmatch(new_method{:},required_methods,'exact'))  % 如果required_methods中不存在一个与new_method{:}完全匹配的字符串
                        required_methods = { required_methods{:}, new_method{:} };  % 跑完所有循环的结果：只添加了一个{'weight_prior'}
                    end
                end
            elseif ~isfield( net, cur_params{i} )  % 如果cur_params{i}是结构体net中没有的字段，则将其添加至net。
                net.( cur_params{i} ) = cur_params{i+1};
            end
        end
    end

    net.p_required_methods = required_methods;  % 更新net的p_required_methods
    
    fields_args = {};  % 用于存储varargin中的部分参数（对应字段）和参数值（对应字段值）（只存储allocators元胞数组中有且varargin中也有的的字段）
    
    if ~isempty( external_packages )  % 如果有外部包，则将其添加至SNN搜索目录中
        snn_include( external_packages{:} );
    end
    
    allocators = {};  % 后面将3个cell为一组（字段名、生成函数、维度），该元胞数组用于分配字段值
    
    % 逐一遍历方法函数名（上面required_methods中方法的全名），从相应文件中读取元数据
    for method_fcn_name = method_fcn_names
        new_allocs = snn_parse_meta_data( [method_fcn_name{:},'.m'], 'fields', 2 );  % 从method_fcn_name.m中读取fields部分的元数据（每次读两个字段）
        allocators = { allocators{:}, new_allocs{:} };  
    end
    
    net.p_allocators = allocators;  % 更新net.p_allocators为读取到的元数据
    
    % 遍历varargin，将参数名在allocators有出现的输入参数名及参数值用元胞数组fields_args收集，并将所有参数和参数值添加至结构体net。
    for i=1:2:length(varargin)
        if (length(varargin{i})>=2) && strcmp( varargin{i}(1:2), 'p_' )  % 如果输入的参数是'p_'开头的参数
            error( 'cant set private parameter ''%s''!', varargin{i} );  % 抛出错误信息：不能设置私有参数varargin{i}
        end
        if any(ismember({allocators{1:3:end}}',varargin{i}))      % 如果varargin{i}是allocators元胞数组中的元素（3个为一组逐组比对）
            fields_args = { fields_args{:}, varargin{i:(i+1)} };  % 将对应的参数名和参数值添加至fields_args元胞数组中
            continue;
        end            
        if ~isfield(net,varargin{i})  % 如果遍历到的参数名不是结构体net中的字段，则发出警告：该参数似乎未被使用
            warning('parameter ''%s'' seems to be unused!', varargin{i} );
        end
        net.( varargin{i} ) = varargin{i+1};  % 更新结构体net
    end
    
    net = snn_alloc( net, net.p_allocators, reset_fields );  % 分配net.p_allocators定义的字段的字段值，并指定是否重新设置字段
    
    for i=1:2:length(fields_args)  % 间隔为2地遍历fields_args
        if (length(fields_args{i})>=2) && strcmp( fields_args{i}(1:2), 'p_' )  % 如果当前遍历到的字段名以'p_'开头（即私有字段）
            error( 'cant set private field ''%s''!', fields_args{i} );         % 抛出错误信息：不能设置私有字段
        end
        a_id = 3*(find(ismember({allocators{1:3:end}}',fields_args{i}))-1)+1;  % 获取fields_args{i}首次在allocators中出现的位置索引
        dim = snn_dispatch_args( net, allocators{a_id+2} );                    % 拿到维度信息
        if any(dim ~= size(fields_args{i+1}))                                  % 如果维度不匹配则抛出错误信息:字段参数的size错误！(应该是dim(1) x dim(2))
            error('field argument ''%s'' hast the wrong size! (should be %i x %i)', fields_args{i}, dim(1), dim(2) );  
        end
        net.( fields_args{i} ) = fields_args{i+1};  % 给结构体net添加相应的键值
    end
end

